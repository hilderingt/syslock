#!/bin/sh
#
#  Read-only Root-FS for Raspian
#
#  Modified 2015 by Pascal Rosin to work on raspian-ua-netinst with
#  overlayfs integrated in Linux Kernel >= 3.18.
#
#  Originally written by Axel Heider (Copyright 2012) for Ubuntu 11.10.
#  This version can be found here:
#  https://help.ubuntu.com/community/aufsRootFileSystemOnUsbFlash#Overlayfs
#
#  Based on scripts from
#    Sebastian P.
#    Nicholas A. Schembri State College PA USA
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see
#    <http://www.gnu.org/licenses/>.
#
#
# Changelog:
#
# v1.0.0
#   - written by Axel Heider for Ubuntu 11.10
#
# v2.0.0
#   - Modified to work with overlayfs integrated in Linux Kernel (>= 3.18)
#   - introduce workdir needed for new overlayfs
#   - change `mount --move` to `mount -o move` to drop busybox requirement
#   - Tested with raspian-ua-netinst v1.0.7
#     (Linux 3.18.0-trunk-rpi, Debian 3.18.5) on a Raspberry Pi.
#     The aufs part is not tested!
#
# Notes:
#   * no changes to the root fs are made by this script.
#   * if /home/[user] is on the RO root fs, files are in ram and not saved.
#
# Install:
#  put this file in /etc/initramfs-tools/scripts/init-bottom/root-ro
#  chmod 0755 /etc/initramfs-tools/scripts/init-bottom/root-ro
#  update-initramfs -u
#  add `root-ro-driver=overlay` to the line in /boot/cmdline.txt
#
# Disable read-only root fs
#   * option 1: kernel boot parameter "disable-root-ro=true"
#   * option 2: create file "/disable-root-ro"
#
# ROOT_RO_DRIVER variable controls which driver isused for the ro/rw layering
#   Supported drivers are: overlayfs, aufs
#  the kernel parameter "root-ro-driver=[driver]" can be used to initialize
#  the variable ROOT_RO_DRIVER. If nothing is given, overlayfs is used.
#

# no pre requirement
PREREQ=""

prereqs()
{
    echo "${PREREQ}"
}

case "$1" in
    prereqs)
    prereqs
    exit 0
    ;;
esac

# import /usr/share/initramfs-tools/scripts/functions
. /scripts/functions

PKGNAME="lockroot"
NOLOCK_FILE="/nolock"

# parse kernel boot command line 
NOLOCK=
for PARAM in $(cat /proc/cmdline); do
    case ${PARAM} in
        nolock)
            NOLOCK=true
            ;;
    esac
done

# check if read-only root fs is disabled
if [ ! "x${NOLOCK}" = "xtrue" ]; then
    log_warning_msg "${PKGNAME}: disabled, found kernel boot parameter 'nonlock'"
    exit 0
fi

if [ -e "${rootmnt}${NOLOCK_FILE}" ]; then
    log_warning_msg "${PKGNAME}: disabled, found file '${rootmnt}${NOLOCK_FILE}'"
    exit 0
fi

# generic settings
# ${ROOT} and ${rootmnt} are predefined by caller of this script. Note that
# the root fs ${rootmnt} it mounted readonly on the initrams, which fits nicely
# for our purposes.
TMP_ROOT_RO=/mnt/ro
TMP_ROOT_RW=/mnt/rw
TMP_ROOT_RW_UPPER=${TMP_ROOT_RW}/upper
TMP_ROOT_RW_WORK=${TMP_ROOT_RW}/work
REAL_ROOT_RW=/.lock/rw
REAL_ROOT_RO=/.lock/ro

# check if kernel module exists
#modprobe -qb ${ROOT_RO_DRIVER}
#if [ $? -ne 0 ]; then
#    log_failure_msg "${PKGNAME} ERROR 2: missing kernel module ${ROOT_RO_DRIVER}"
#    exit 0
#fi

# make the mount point on the init root fs ${TMP_ROOT_RW}
[ -d ${TMP_ROOT_RW} ] || mkdir -p ${TMP_ROOT_RW}
if [ $? -ne 0 ]; then
    log_failure_msg "${PKGNAME}: ERROR 3: failed to create ${TMP_ROOT_RW}"
    exit 0
fi

# make the mount point on the init root fs ${TMP_ROOT_RO}
[ -d ${TMP_ROOT_RO} ] || mkdir -p ${TMP_ROOT_RO}
if [ $? -ne 0 ]; then
    log_failure_msg "${PKGNAME}: ERROR 4: failed to create ${TMP_ROOT_RO}"
    exit 0
fi

# make the mount point on the init root fs ${TMP_ROOT_RW_WORK}
[ -d ${TMP_ROOT_RW_WORK} ] || mkdir -p ${TMP_ROOT_RW_WORK}
if [ $? -ne 0 ]; then
    log_failure_msg "${PKGNAME}: ERROR 5: failed to create ${TMP_ROOT_RW_WORK}"
    exit 0
fi


# mount a tempfs using the device name tmpfs-root at ${TMP_ROOT_RW}
mount -t tmpfs tmpfs-root ${TMP_ROOT_RW}
if [ $? -ne 0 ]; then
    log_failure_msg "${PKGNAME}: ERROR 6: failed to create tmpfs for root filesystem"
    exit 0
fi

[ -d ${TMP_ROOT_RW_UPPER} ] || mkdir -p ${TMP_ROOT_RW_UPPER}
if [ $? -ne 0 ]; then
    log_failure_msg "${PKGNAME}: ERROR 6.1: failed to create ${TMP_ROOT_RW_UPPER}"
    exit 0
fi

[ -d ${TMP_ROOT_RW_WORK} ] || mkdir -p ${TMP_ROOT_RW_WORK}
if [ $? -ne 0 ]; then
    log_failure_msg "${PKGNAME}: ERROR 6.2: failed to create ${TMP_ROOT_RW_WORK}"
    exit 0
fi

# root is mounted on ${rootmnt}, move it to ${TMP_ROOT_RO}.
mount -o move ${rootmnt} ${TMP_ROOT_RO}
if [ $? -ne 0 ]; then
    log_failure_msg "${PKGNAME}: ERROR 7: failed to move root filesystem from ${rootmnt} to ${TMP_ROOT_RO}"
    exit 0
fi

# there is nothing left at ${rootmnt} now. So for any error we get we should
# either do recovery to restore ${rootmnt} for drop to a initramfs shell using
# "panic". Otherwise the boot process is very likely to fail with even more
# errors and leave the system in a wired state.

# mount virtual fs ${rootmnt} with rw-fs ${TMP_ROOT_RW} on top of ro-fs ${TMP_ROOT_RO}.
mount -t overlay -o lowerdir=${TMP_ROOT_RO},upperdir=${TMP_ROOT_RW_UPPER},workdir=${TMP_ROOT_RW_WORK} overlay ${rootmnt}
if [ $? -ne 0 ]; then
    log_failure_msg "${PKGNAME}: ERROR 8: failed to create overlay for root filesystem"
    # do recovery and try resoring the mount for ${rootmnt}
    mount -o move ${TMP_ROOT_RO} ${rootmnt}
    if [ $? -ne 0 ]; then
       # thats bad, drop to shell to let the user try fixing this
       panic "${PKGNAME}: RECOVERY ERROR: failed to move root filesystem back to ${rootmnt}"
    fi
    exit 0
fi

# now the real root fs is on ${ROOT_RO} of the init file system, our layered
# root fs is set up at ${rootmnt}. So we can write anywhere in {rootmnt} and the
# changes will end up in ${ROOT_RW} while ${ROOT_RO} it not touched. However
# ${ROOT_RO} and ${ROOT_RW} are on the initramfs root fs, which will be removed
# an replaced by ${rootmnt}. Thus we must move ${ROOT_RO} and ${ROOT_RW} to the
# rootfs visible later, ie. ${rootmnt}${ROOT_RO} and ${rootmnt}${ROOT_RO}.
# Since the layered ro/rw is already up, these changes also end up on
# ${ROOT_RW} while ${ROOT_RO} is not touched.

# move mount from ${TMP_ROOT_RO} to ${rootmnt}${REAL_ROOT_RO}
[ -d ${rootmnt}${REAL_ROOT_RO} ] || mkdir -p ${rootmnt}${REAL_ROOT_RO}
mount -o move ${TMP_ROOT_RO} ${rootmnt}${REAL_ROOT_RO}
if [ $? -ne 0 ]; then
    log_failure_msg "${PKGNAME}: ERROR 9: failed to move ${TMP_ROOT_RO} to ${rootmnt}${REAL_ROOT_RO}"
    exit 0
fi

# move mount from ${TMP_ROOT_RW} to ${rootmnt}${REAL_ROOT_RW}
[ -d ${rootmnt}${REAL_ROOT_RW} ] || mkdir -p ${rootmnt}${REAL_ROOT_RW}
mount -o move ${TMP_ROOT_RW} ${rootmnt}${REAL_ROOT_RW}
if [ $? -ne 0 ]; then
    log_failure_msg "${PKGNAME}: ERROR 10: failed to move ${TMP_ROOT_RW} to ${rootmnt}${REAL_ROOT_RW}"
    exit 0
fi

# technically, everything is set up nicely now. Since ${rootmnt} had beend
# mounted read-only on the initfamfs already, ${rootmnt}${ROOT_RO} is it, too.
# Now we init process could run - but unfortunately, we may have to prepare
# some more things here.
# Basically, there are two ways to deal with the read-only root fs. If the
# system is made aware of this, things can be simplified a lot.
# If it is not, things need to be done to our best knowledge.
#
# So we assume here, the system does not really know about our read-only root fs.
#
# Let's deal with /etc/fstab first. It usually contains an entry for the root
# fs, which is no longer valid now. We have to remove it and add our new
# ${REAL_ROOT_RO} entry.
# Remember we are still on the initramfs root fs here, so we have to work on
# ${rootmnt}/etc/fstab. The original fstab is ${rootmnt}${REAL_ROOT_RO}/etc/fstab.
ROOT_FSTYPE_MNTOPTS=$(cat /proc/mounts | ${rootmnt}/bin/grep ${ROOT} | ${rootmnt}/usr/bin/cut -d' ' -f3,4)
cat <<EOF >${rootmnt}/etc/fstab
#
#  This fstab is in RAM, the real one can be found at ${ROOT_RO}/etc/fstab
#  The original entry for '/' and all swap files have been removed.  The new
#  entry for the read-only the real root fs follows. Write access can be
#  enabled using:
#    sudo mount -o remount,rw ${REAL_ROOT_RO}
#  re-mounting it read-only is done using:
#    sudo mount -o remount,ro ${REAL_ROOT_RO}
#

${ROOT} ${REAL_ROOT_RO} ${ROOT_FSTYPE_MNTOPTS} 0 0

#
#  remaining entries from the original ${REAL_ROOT_RO}/etc/fstab follow.
#
EOF
if [ $? -ne 0 ]; then
    log_failure_msg "${PKGNAME}: ERROR 11: failed to modify original root filsystem fstab entry"
    #exit 0
fi

#remove root entry and swap from fstab
cat ${rootmnt}${REAL_ROOT_RO}/etc/fstab | ${rootmnt}/bin/grep -v ' / ' | ${rootmnt}/bin/grep -v swap >>${rootmnt}/etc/fstab
if [ $? -ne 0 ]; then
    log_failure_msg "${PKGNAME}: ERROR 12: failed to delete fstab entries for root filesystem and swap"
    #exit 0
fi

# now we are done. Additinal steps may be necessary depending on the actualy
# distribution and/or its configuration.

log_success_msg "${PKGNAME}: sucessfully set up overlay for root filesystem"

exit 0